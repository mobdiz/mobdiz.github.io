<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">

  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <title>Triangles</title>

  <!-- Normalize CSS (cdn) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">

  <style>
    body {
      display: grid;
      grid-template-columns: 1fr;
      grid-gap: 20px;
      align-items: center;
      align-content: center;
      justify-content: center;
      justify-items: center;
      padding: 20px;
      min-height: 100vh;
    }

    .main {
      width: 500px;
      height: 500px;
      border: 1px solid #000;
      position: relative;
    }

    .dot {
      width: 3px;
      height: 3px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background-color: #000;
      position: absolute;
    }

    .dot::before {
      content: attr(data-name);
      position: absolute;
      bottom: 100%;
      left: 110%;
      line-height: 1;
    }

    .line {
      height: 1px;
      background-color: #000;
      position: absolute;
      transform-origin: left center;
    }
  </style>
</head>
<body>

<div id="app">
  <div>
    <h1>Dots ({{ dots.count }})</h1>

    <div class="main">
      <div v-for="dot in $mainDots" :key="for"></div>
    </div>

    <button class="btn js-draw-new-dot">Start/Pause</button>
  </div>
</div>

<script src="https://unpkg.com/petite-vue"></script>

<script>
  const App = PetiteVue.createApp().mount('#app')

  // const mainEl = document.querySelector('.main')
  // const drawNewDotBtn = document.querySelector('.js-draw-new-dot')
  // const dotsCounterEl = document.querySelector('.dots-counter')
  //
  // const dots = {
  //   a: [40, 70],
  //   b: [400, 150],
  //   c: [274, 400],
  // }
  //
  // const dotsInts = new Map([
  //   [1, dots.a],
  //   [2, dots.a],
  //   [3, dots.b],
  //   [4, dots.b],
  //   [5, dots.c],
  //   [6, dots.c],
  // ])
  //
  // const newDots = []
  //
  // let lastDot = dots.c;
  //
  // let drawNewDotInterval = null
  //
  // let isDrawing = false
  //
  // const vertices = Object.values(dots)
  //
  // function drawDot(x, y, name) {
  //   const dot = document.createElement('div')
  //
  //   dot.classList.add('dot')
  //
  //   if (name) {
  //     dot.classList.add(`dot-${name}`)
  //     dot.dataset.name = name
  //   }
  //
  //   dot.style.left = x + 'px'
  //   dot.style.top = y + 'px'
  //
  //   mainEl.appendChild(dot)
  // }
  //
  // function getRandomInt(min = 1, max = 6) {
  //   return Math.floor(Math.random() * (max - min + 1)) + min;
  // }
  //
  // function drawLineBetweenDots(dot1, dot2) {
  //   const line = document.createElement('div')
  //   const dot1El = document.querySelector(`.dot-${dot1}`)
  //   const dot2El = document.querySelector(`.dot-${dot2}`)
  //
  //   line.classList.add('line')
  //
  //   line.style.width = Math.sqrt((dot1El.offsetLeft - dot2El.offsetLeft) ** 2 + (dot1El.offsetTop - dot2El.offsetTop) ** 2) + 'px'
  //   line.style.transform = `rotate(${Math.atan2(dot2El.offsetTop - dot1El.offsetTop, dot2El.offsetLeft - dot1El.offsetLeft)}rad)`
  //   line.style.left = dot1El.offsetLeft + 'px'
  //   line.style.top = dot1El.offsetTop + 'px'
  //
  //   mainEl.appendChild(line)
  // }
  //
  // function isPointInside(point) {
  //   let inside = false;
  //
  //   for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
  //     const xi = vertices[i][0], yi = vertices[i][1];
  //     const xj = vertices[j][0], yj = vertices[j][1];
  //
  //     const intersect = ((yi > point[1]) !== (yj > point[1])) &&
  //       (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
  //
  //     if (intersect) {
  //       inside = !inside
  //     }
  //   }
  //
  //   return inside;
  // }
  //
  // function getRandomPointInside() {
  //   const xMin = Math.min(...vertices.map(v => v[0]));
  //   const yMin = Math.min(...vertices.map(v => v[1]));
  //   const xMax = Math.max(...vertices.map(v => v[0]));
  //   const yMax = Math.max(...vertices.map(v => v[1]));
  //
  //   while (true) {
  //     const x = Math.random() * (xMax - xMin) + xMin;
  //     const y = Math.random() * (yMax - yMin) + yMin;
  //
  //     const point = [x, y];
  //
  //     if (isPointInside(point)) {
  //       return point;
  //     }
  //   }
  // }
  //
  // function drawNewDot() {
  //   if (newDots.length === 0) {
  //     const point = getRandomPointInside();
  //
  //     newDots.push(point);
  //
  //     lastDot = point;
  //
  //     drawDot(point[0], point[1])
  //   } else {
  //     const randomInt = getRandomInt();
  //
  //     const dot = dotsInts.get(randomInt);
  //
  //     // Вычислить точку между последней точкой и выбранной точкой
  //     const x = (lastDot[0] + dot[0]) / 2;
  //     const y = (lastDot[1] + dot[1]) / 2;
  //
  //     const newDot = [x, y];
  //
  //     newDots.push(newDot);
  //
  //     dotsCounterEl.innerHTML = String(newDots.length)
  //
  //     lastDot = newDot;
  //
  //     drawDot(x, y);
  //   }
  // }
  //
  // function handleDrawNewDotBtn(event) {
  //   event.preventDefault()
  //
  //   if (!isDrawing) {
  //     isDrawing = true
  //
  //     drawNewDotInterval = setInterval(() => {
  //       drawNewDot()
  //     }, 1000 / 60)
  //   } else {
  //     isDrawing = false
  //
  //     clearInterval(drawNewDotInterval)
  //   }
  // }
  //
  // const dotsKeys = Object.keys(dots)
  //
  // dotsKeys.forEach((key) => {
  //   drawDot(dots[key][0], dots[key][1], key)
  // })
  //
  // dotsKeys.forEach((key, i) => {
  //   if (i === 0) {
  //     drawLineBetweenDots(key, dotsKeys[dotsKeys.length - 1])
  //   } else {
  //     drawLineBetweenDots(key, dotsKeys[i - 1])
  //   }
  // })
  //
  // document.addEventListener('DOMContentLoaded', () => {
  //   drawNewDotBtn.addEventListener('click', handleDrawNewDotBtn)
  // })
</script>
</body>
</html>
